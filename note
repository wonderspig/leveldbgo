1.同一个目录下的文件的包名必须要相同，否则编译会报错；
2.go语言中，通过变量或者函数(普通函数和成员函数)首字母是否大写来限定他的访问权限，小写限制:只能在同一个包内使用，注意
可能会跨文件；
3.成员函数或变量，必须要使用基于对象的方式进行调用，即：obj.Member;
4.import紧跟的是路径名，所以最后一个并不是包名，只是大部分时包名和该目录名相同而已


//go和原版leveldb上的一些区别
5.在C++版本的leveldb中，使用EncodeVarint来进行存储，为的是节省空间。
5.1优点
节省空间：比如int32类型的数字，一般需要4个字节。但是采用Varint，对于很小的int32类型的数字，
则可以用1个字节来表示。
5.2缺点
当然凡事都有好的也有不好的一面，采用varint表示法，大的数字则可能需要5个字节来表示。从统计的角度来说，一般不会所有消息中的数字都是大数，
因此大多数情况下，采用varint后，可以用更小的字节数来表示数字信息。
5.3特点
varint中的每个字节的最高位(bit)都有特殊含义。如果该位为1，表示后续的字节也为该数字的一部分，如果该位为0，则结束。
其他的7bit都表示数字，7位能表示的最大数为127，因此小于128的数字都可以用一个字节来表示，大于等于128的，比如300，需要用两个字节。
例如:300
300的二进制100101100，低位7位二进制位0101100，剩下的两位10，因此组合起来为10101100 0000010，由于第一个后面还有，因此第一个字节的第一位为1，而第二个字节的第一位为0.
5.4具体实现
正常情况一下，一个int32需要32位，但一个字节只能存储7位，如果整数特别大，可能需要5个字节才能存放(5*8-5(每个字节标志位)>32).

实例代码：
char* EncodeVarint64(char* dst, uint64_t v) {
  static const int B = 128;
  unsigned char* ptr = reinterpret_cast(dst);
  while (v >= B) {
    *(ptr++) = (v & (B-1)) | B;
    v >>= 7;
  }
  //这里强转，利用自动截断的原理，刚好可以获取剩下的
  *(ptr++) = static_cast(v);
  return reinterpret_cast(ptr);
}

6.func ChangeValue([]byte),使用的是引用传参，因此修改形参会影响实参的值.但是切片不会影响原来的值


7.string基本操作
 7.1string转int64以及string切片
 strconv.ParseInt(secondNum[len(secondNum)-8:len(secondNum)], 10, 64)





